# FAQ

### **What Formality aims to be?**

Formality aims to to be both a general-purpose programming language, in the sense it can be used to build algorithms, applications, smart-contracts and anything else, not unlike Python, JavaScript and similars, and a proof language, in the sense it can express and prove mathematical theorems about its own programs, not unlike Agda, Idris and Coq.

### **What is the difference between Formality and other proof languages like Agda, Coq and Idris?**

Formality has two main differences due to its planned usage in the context of Smart-Contracts.

1. It aims to be not just a single implementation, but also a well-documented, minimalist specification which can be used by developers to implement it independently without much effort. This is important, because it removes the need for users to trust in a single, big "official implementation". For comparison purposes, the current reference implementation of Formality has only 500 lines of code, while Coq's core has , Idris has , and Agda has <???>.
2. It is built from the beginning with efficiency as a priority. That means it includes a series of restrictions that make it more compatible with NASIC and, thus, more lightweight and faster than other proof languages, allowing its programs to run in architectures where performance is essential. This includes, for example, Smart-Contracts, where each operation has a monetary cost, or even graphics and scientific applications, which usually run in massively parallel architectures such as the GPU.

### **What is NASIC?**

NASIC is short for N-Ary Symmetric Interaction Combinators, a graph-based model of computation used as the main compile target for Formality. It has a similar role to ASM for C, or the STG for Haskell. Compared to those, it has very good computational properties:

1. It is inherently parallel, meaning you can reduce NASIC graphics in massively parallel architectures like the GPU.
2. It is strongly confluent, which gives us a very clear cost model for use-cases like gas metering.
3. It can be used to implement optimal reductions for the λ-calculus.

NASIC is based on [Symmetric Interaction Combinators](https://pdfs.semanticscholar.org/1731/a6e49c6c2afda3e72256ba0afb34957377d3.pdf), with two main changes:

1. Instead of only two node "labels" (δ and ζ), nodes can be labelled with 32-bit integers. This is what allows efficient evaluation of Formality programs through "boxes" and "levels".
2. For simplicity, there isn't an erasure node. Instead, we use a fan node wired with each port wired to itself, which is equivalent.

### **What is the relationship between Formality and Cedille?**

Cedille is a language invented by Aaron Stump that shares similar goals to Formality, in special minimalism. For a while, [Cedille-Core](https://github.com/MaiaVictor/Cedille-Core) was actually planned to be used instead of Formality on Ethereum. Sadly, when trying to do so, I got stuck due to some problems which I explain [in this article](https://medium.com/@maiavictor/towards-a-simple-theorem-prover-5005a1e66a6f). This led me to design a new language, [ESCoC](https://github.com/maiavictor/escoc), which is better-suited for my goals. Compared to Cedille-Core, ESCoC is simpler to implement (60-70% smaller), simpler to use (declaring datatypes take 60-70% less code), and more compatible with NASIC. Formality is just a product name for ESCoC.

### **Why can't Formality be considered a proof language yet?**

Because, unlike Cedille and Coq's core, we don't have a model for Formality yet. The language, as presented currently, is inconsistent and trivial, which means it can't be used as a proper proof language. It is perfectly fine as a programming language, though. In order to enable logical reasoning, we must identify a sound, consistent fragment of Formality, which is what we are doing right now.

### **What are the challenges for achieving consistency?**

In order to derive inductive datatypes so succinctly, Formality must feature mutually recursive definitions. This, unfortunatelly, is known to introduce inconsistencies. Fortunatelly, though, the same set of restrictions required to make Formality compatible with NASIC has also [been proven](http://www.kurims.kyoto-u.ac.jp/~terui/lastfin.pdf) to be consistent with the presence of type-level recursion. Our challenge is, thus, to formalize Formality and attempt to use the same idea to prove it is consistent under those restrictions.